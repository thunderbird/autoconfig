/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

use crate::error::ValidationError;
use crate::types::{ClientConfig, IncomingServer, IncomingServerType};
use regex::Regex;

/// The values that are known and supported for templating in a server's
/// `username` element.
const SUPPORTED_USERNAME_TEMPLATE: [&str; 4] = [
    "%EMAILADDRESS%",
    "%EMAILLOCALPART%",
    "%EMAILDOMAIN%",
    "%REALNAME%",
];

/// Performs a series of checks on the provided `ClientConfig`, such as ensuring
/// its version is supported, that a server's configuration is consistent with
/// its type, etc.
///
/// This function only ensures the configuration *looks* valid, but does not
/// perform any connectivity check.
//
// TODO: Return multiple errors at once (without bailing on the first one),
//  associating each with a path to the invalid element in the config structure.
pub fn validate(cfg: &ClientConfig) -> Result<(), ValidationError> {
    // Ensure the config uses a supported version.
    if cfg.version.as_str() != "1.1" {
        return Err(ValidationError::UnsupportedVersion(cfg.version.clone()));
    }

    // Validate the configurations for incoming servers.
    cfg.email_provider
        .incoming_servers
        .iter()
        .try_for_each(validate_incoming_server)?;

    // Validate the configuration for outgoing servers. This involve
    cfg.email_provider
        .outgoing_servers
        .iter()
        .try_for_each(|server| validate_username(&server.username))
}

/// Performs a series of checks on an individual [`IncomingServer`].
///
/// Ensures any optional protocol-specific configuration on the server matches
/// with the server's type, and that it isn't using any unsupported username
/// template placeholder.
fn validate_incoming_server(server: &IncomingServer) -> Result<(), ValidationError> {
    // Ensure that Exchange-specific configuration is only set for Exchange
    // servers.
    if (server.ews_url.is_some() || server.owa_url.is_some())
        && server.server_type != IncomingServerType::Exchange
    {
        return Err(ValidationError::InvalidIncomingConfig {
            server_type: server.server_type.clone(),
            found: IncomingServerType::Exchange,
        });
    }

    // Ensure that POP3-specific configuration is only set for POP3 servers.
    if server.pop3.is_some() && server.server_type != IncomingServerType::POP3 {
        return Err(ValidationError::InvalidIncomingConfig {
            server_type: server.server_type.clone(),
            found: IncomingServerType::POP3,
        });
    }

    // Ensure that the username uses valid template placeholder(s), if any.
    validate_username(&server.username)?;

    Ok(())
}

/// Ensures the given username uses only supported template placeholder(s), if
/// any.
///
/// The same `username` element can include multiple placeholders, but they all
/// must be supported.
fn validate_username(username: &String) -> Result<(), ValidationError> {
    let re = match Regex::new("%[^%]*%") {
        Ok(re) => re,
        Err(e) => return Err(ValidationError::Unexpected(e.into())),
    };

    for re_match in re.find_iter(username.as_str()) {
        if !SUPPORTED_USERNAME_TEMPLATE.contains(&re_match.as_str()) {
            return Err(ValidationError::InvalidUsernameTemplate(
                re_match.as_str().into(),
            ));
        }
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    /// Tests for the validation checks that are implemented in this module.
    ///
    /// TODO: validation of a full `ClientConfig` class that:
    ///   * is valid
    ///   * contains at least one invalid incoming server
    ///   * contains at least one invalid outgoing server (i.e. invalid username)
    use super::*;

    use crate::error::ValidationError;
    use crate::types::{AuthType, POP3Config, SocketType};

    /// Instantiates a [`IncomingServer`] to use in tests.
    ///
    /// The instance generated by this method is valid as far as the validation
    /// checks in this module are concerned.
    fn generate_incoming_server() -> IncomingServer {
        IncomingServer {
            server_type: IncomingServerType::IMAP,
            hostname: "test.invalid".to_string(),
            port: 993,
            socket_type: SocketType::SSL,
            username: "%EMAILADDRESS%".to_string(),
            authentication: AuthType::PasswordCleartext,
            ews_url: None,
            owa_url: None,
            pop3: None,
            use_global_preferred_server: None,
        }
    }

    /// Tests that a valid [`IncomingServer`] passes validation with no error.
    #[test]
    fn test_validate_incoming_server_valid() -> Result<(), ValidationError> {
        let server = generate_incoming_server();
        validate_incoming_server(&server)
    }

    /// Tests that an [`IncomingServer`] which type isn't POP3 and has a POP3
    /// configuration fails validation with the correct error.
    #[test]
    fn test_validate_incoming_server_unexpected_pop3() -> Result<(), ValidationError> {
        let mut server = generate_incoming_server();
        server.pop3 = Some(POP3Config {
            leave_messages_on_server: None,
            download_on_biff: None,
            check_interval: None,
        });

        let result = validate_incoming_server(&server);

        assert!(result.is_err(), "result should be an error");
        let err = result.err().unwrap();
        assert!(
            matches!(
                err,
                ValidationError::InvalidIncomingConfig {
                    server_type: IncomingServerType::IMAP,
                    found: IncomingServerType::POP3,
                },
            ),
            "error should be a ValidationError::InvalidIncomingConfig, with found = POP3"
        );

        Ok(())
    }

    /// Tests that an [`IncomingServer`] which type isn't Exchange and has an
    /// EWS URL correctly fails validation.
    #[test]
    fn test_validate_incoming_server_unexpected_exchange_ews() -> Result<(), ValidationError> {
        let mut server = generate_incoming_server();
        server.ews_url = Some("test.invalid".to_string());

        let result = validate_incoming_server(&server);

        assert!(result.is_err(), "result should be an error");
        let err = result.err().unwrap();
        assert!(
            matches!(
                err,
                ValidationError::InvalidIncomingConfig {
                    server_type: IncomingServerType::IMAP,
                    found: IncomingServerType::Exchange,
                }
            ),
            "error should be a ValidationError::InvalidIncomingConfig, with found = Exchange"
        );

        Ok(())
    }

    /// Tests that an [`IncomingServer`] which type isn't Exchange and has an
    /// OWA URL correctly fails validation.
    #[test]
    fn test_validate_incoming_server_unexpected_exchange_owa() -> Result<(), ValidationError> {
        let mut server = generate_incoming_server();
        server.owa_url = Some("test.invalid".to_string());

        let result = validate_incoming_server(&server);

        assert!(result.is_err(), "result should be an error");
        let err = result.err().unwrap();
        assert!(
            matches!(
                err,
                ValidationError::InvalidIncomingConfig {
                    server_type: IncomingServerType::IMAP,
                    found: IncomingServerType::Exchange,
                }
            ),
            "error should be a ValidationError::InvalidIncomingConfig, with found = Exchange"
        );

        Ok(())
    }

    /// Tests that a username that contains no placeholder passes username
    /// validation with no error.
    #[test]
    fn test_validate_username_no_placeholder() -> Result<(), ValidationError> {
        validate_username(&"foo".into())
    }

    /// Tests that a username that contains a known placeholder passes username
    /// validation with no error.
    #[test]
    fn test_validate_username_known_placeholder() -> Result<(), ValidationError> {
        validate_username(&"%EMAILADDRESS%".into())
    }

    /// Tests that a username that contains an unknown placeholder correctly
    /// fails username validation.
    #[test]
    fn test_validate_username_unknown_placeholder() -> Result<(), ValidationError> {
        assert!(
            matches!(
                validate_username(&"%FOO%".to_string()),
                Err(ValidationError::InvalidUsernameTemplate(..))
            ),
            "username validation should return a ValidationError::InvalidUsernameTemplate error"
        );

        Ok(())
    }

    /// Tests that a username that contains multiple known placeholders passes
    /// username validation with no error.
    #[test]
    fn test_validate_username_multiple_placeholder_valid() -> Result<(), ValidationError> {
        validate_username(&"%EMAILLOCALPART%.%EMAILDOMAIN%".to_string())
    }

    /// Tests that a username that contains multiple placeholders with at least
    /// one unknown correctly fails username validation
    #[test]
    fn test_validate_username_multiple_placeholder_one_unknown() -> Result<(), ValidationError> {
        assert!(
            matches!(
                validate_username(&"%EMAILLOCALPART%.%FOO%".to_string()),
                Err(ValidationError::InvalidUsernameTemplate(..))
            ),
            "username validation should return a ValidationError::InvalidUsernameTemplate error"
        );

        Ok(())
    }
}
